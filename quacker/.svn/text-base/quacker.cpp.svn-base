/*
 * Copyright (c) 2005-2006 Jason Katz-Brown and John O'Laughlin.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The names of the authors may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <iostream>
using namespace std;

#include <QtGui>

#include <game.h>
#include <boardparameters.h>
#include <strategyparameters.h>
#include <strongplayer.h>
#include <gameparameters.h>

#include "brb.h"
#include "dashboard.h"
#include "history.h"
#include "lexiconparameters.h"
#include "movebox.h"
#include "newgame.h"
#include "quacker.h"
#include "simviewer.h"
#include "util.h"
#include "widgetfactory.h"
#include "view.h"

TopLevel *TopLevel::m_self = 0;
TopLevel *TopLevel::self()
{
	return m_self;
}

TopLevel::TopLevel(QWidget *parent)
	: QMainWindow(parent), m_plies(1), m_modified(false)
{
	m_self = this;

	QCoreApplication::setOrganizationName("Quackle Software");
	QCoreApplication::setOrganizationDomain("quackle.org");
	QCoreApplication::setApplicationName("Quackle");

	setAttribute(Qt::WA_DeleteOnClose);
	
	m_dataManager.setDataDirectory("../data");
	m_dataManager.setBoardParameters(new Quackle::ScrabbleBoard());

	const string lexicon = "twl06";
	m_dataManager.lexiconParameters()->loadDawg(Quackle::LexiconParameters::findDictionaryFile(lexicon + ".dawg"));
	m_dataManager.strategyParameters()->initialize(Quackle::StrategyParameters::findStrategyDirectory(lexicon));

	m_game = new Quackle::Game;
	m_simulator = new Quackle::Simulator;

	m_game->setDefaultComputerPlayer(new Quackle::StrongPlayer);

	createWidgets();
	createMenu();
	loadSettings();

	statusMessage(tr("Initializing..."));
	setCaption(tr("Welcome"));

	QTimer::singleShot(0, this, SLOT(finishInitialization()));
}

TopLevel::~TopLevel()
{
	saveSettings();
	delete m_game;
	delete m_simulator;
}

void TopLevel::closeEvent(QCloseEvent *closeEvent)
{
	pause(true);

	if (m_modified)
	{
		switch (askToSave())
		{
		case 0:
			qApp->processEvents();
			writeFile();

			// fall through

		case 1:
			closeEvent->accept();
			break;

		case 2:
			closeEvent->ignore();
		}
	}
	else
		closeEvent->accept();
}

void TopLevel::finishInitialization()
{
	// make sure we have generator prepared
	m_dataManager.generator();

	m_timer = new QTimer(this);
	connect(m_timer, SIGNAL(timeout()), this, SLOT(timeout()));
	m_simulationTimer = new QTimer(this);
	connect(m_simulationTimer, SIGNAL(timeout()), this, SLOT(incrementSimulation()));
	
	// shall we initialize game when we load the application?
	// we should but I don't know a good way
	//initializeGame();

	statusMessage(tr("Enjoy your quackling."));
}

void TopLevel::commit()
{
	if (m_game->candidate().isAMove())
	{
		// stop simulation if it's going
		simulate(false);

		m_game->commitCandidate();

		advanceGame();
	}
	else
	{
		statusMessage(tr("No move specified."));
	}
}

void TopLevel::statusMessage(const QString &message)
{
	statusBar()->showMessage(message);
}

bool TopLevel::askToCarryOn(const QString &text, IffyPlayType /* type */)
{
	return QMessageBox::question(this, tr("Verify Play"), text, QMessageBox::Yes, QMessageBox::No) == QMessageBox::Yes;
}

void TopLevel::setCandidateMove(const Quackle::Move &move)
{
	Quackle::Move prettiedMove(move);
	m_game->currentPosition().ensureMovePrettiness(prettiedMove);

	if (m_game->currentPosition().moves().contains(prettiedMove))
		m_game->setCandidate(m_game->currentPosition().scoreMove(prettiedMove));
	else
	{
		bool carryOn = false;

		switch (m_game->currentPosition().validateMove(prettiedMove))
		{
			case Quackle::GamePosition::ValidMove:
				carryOn = true;
				break;

			case Quackle::GamePosition::TooLateExchange:
				statusMessage(tr("Bag must contain at least %1 tiles for an exchange.").arg(Quackle::DataManager::self()->parameters()->minimumTilesForExchange()));
				break;

			case Quackle::GamePosition::InvalidTiles:
				carryOn = askToCarryOn(tr("%1's rack does not include all tiles in %2; make play anyway?").arg(Util::stringToQString(m_game->currentPosition().currentPlayer().name())).arg(Util::moveToDetailedString(prettiedMove)), IffyTiles);
				break;

			case Quackle::GamePosition::InvalidPlace:
				statusMessage(tr("%1 does not connect to other plays on board").arg(Util::moveToDetailedString(prettiedMove)));
				break;

			case Quackle::GamePosition::InvalidAction:
				statusMessage(tr("Urps"));
				break;
		}

		if (!carryOn)
			return;

		m_game->currentPosition().addAndSetMoveMade(m_game->currentPosition().scoreMove(prettiedMove));
		switchToTab(ChoicesTabIndex);
		ensureUpToDateSimulatorMoveList();
	}

	updatePositionViews();

	// this duplicates the job of updateMoveViews as it also does
	// a check if we have simulation results -- but we don't want to send out
	// a moves changed signal if we don't have results because
	// we just sent out a position changed signal
	if (m_simulator->hasSimulationResults())
		updateMoveViews();
}

void TopLevel::removeCandidateMoves(const Quackle::MoveList &moves)
{
	const Quackle::MoveList::const_iterator end(moves.end());
	for (Quackle::MoveList::const_iterator it = moves.begin(); it != end; ++it)
		m_game->currentPosition().removeMove(*it);

	updateMoveViews();
	ensureUpToDateSimulatorMoveList();
}

void TopLevel::setRack(const Quackle::Rack &rack)
{
	m_game->currentPosition().setCurrentPlayerRack(rack);
	m_simulator->currentPosition().setCurrentPlayerRack(rack);
	updatePositionViews();

	statusMessage(tr("%1's rack set to %2").arg(Util::stringToQString(m_game->currentPosition().currentPlayer().name())).arg(Util::stringToQString(rack.tiles())));
}

void TopLevel::goToHistoryLocation(const Quackle::HistoryLocation &location)
{
	// stop simulation if it's going
	simulate(false);

	m_game->setCurrentPosition(location);
	itIsNowHumanTurn();
}

void TopLevel::updatePositionViews()
{
	emit positionChanged(m_game->currentPosition());

	m_simulateAction->setEnabled(!m_game->currentPosition().moves().empty());
	m_kibitzAction->setEnabled(!m_game->currentPosition().gameOver());
	m_kibitzAllAction->setEnabled(!m_game->currentPosition().gameOver());
	m_commitAction->setEnabled(!m_game->currentPosition().gameOver() && m_game->currentPosition().moveMade().isAMove());
}

void TopLevel::updateMoveViews()
{
	if (m_simulator->hasSimulationResults())
		emit movesChanged(m_simulator->moves(/* prune */ true));
	else
		emit movesChanged(m_game->currentPosition().moves());

	m_simulateAction->setEnabled(!m_game->currentPosition().moves().empty());
}

void TopLevel::updateHistoryViews()
{
	emit historyChanged(m_game->history());
}

void TopLevel::initializeGame(const Quackle::PlayerList &players)
{
	m_game->reset();

	if (players.empty())
		return;

	Quackle::PlayerList newPlayers(players);

	// shuffle so same person doesn't go first twice in a row,
	// if there are multiple players in the game
	if (newPlayers.size() > 1)
	{
		wstring prevFirst = m_firstPlayerName;
		while (m_firstPlayerName == prevFirst || m_firstPlayerName.empty())
		{
			random_shuffle(newPlayers.begin(), newPlayers.end());
			m_firstPlayerName = newPlayers.front().name();
		}
	}

	m_game->setPlayers(newPlayers);
	m_game->addPosition();
	
	advanceGame();

	setCaption(gameTitle());

	// DEBUG ENDGAME
	/*
	{
		for (int i = 0; i < 18; ++i)
			m_game->haveComputerPlay();
		advanceGame();
	}
	*/
}

void TopLevel::open()
{
	return unimplemented();
	pause(true);

	if (m_modified)
	{
		switch (askToSave())
		{
		case 0:
			writeFile();

		case 1:
			break;

		case 2:
			return;
		}
	}
	
	// QString getOpenFileName ( QWidget * parent = 0, const QString & caption = QString(), const QString & dir = QString(), const QString & filter = QString(), QString * selectedFilter = 0, Options options = 0 )
	QString filename = QFileDialog::getOpenFileName(this);
	if (!filename.isEmpty())
	{
		m_filename = filename;
		loadFile();
		saveSettings();
	}
}

void TopLevel::newGame()
{
	pause(true);

	if (m_modified)
	{
		switch (askToSave())
		{
		case 0:
			writeFile();

		case 1:
			break;

		case 2:
			return;
		}
	}
	
	NewGameDialog newGameDialog(this);
	switch (newGameDialog.exec())
	{
	case QDialog::Accepted:
		initializeGame(newGameDialog.players());
		break;

	case QDialog::Rejected:
		break;
	}
}

void TopLevel::setCaption(const QString &text)
{
	if (!text.isNull())
		m_ourCaption = text;

	setWindowTitle(QString("%1[*] - Quackle").arg(m_ourCaption));
}

void TopLevel::setModified(bool modified)
{
	m_modified = modified;
	setWindowModified(m_modified);
}

bool TopLevel::setupCheck()
{
	return true;
}

void TopLevel::plugIntoBaseMatrix(BaseView *view)
{
	connect(view, SIGNAL(statusMessage(const QString &)), this, SLOT(statusMessage(const QString &)));
}

void TopLevel::plugIntoMatrix(View *view)
{
	plugIntoBaseMatrix(view);

	connect(view, SIGNAL(setCandidateMove(const Quackle::Move &)), this, SLOT(setCandidateMove(const Quackle::Move &)));
	connect(view, SIGNAL(removeCandidateMoves(const Quackle::MoveList &)), this, SLOT(removeCandidateMoves(const Quackle::MoveList &)));
	connect(view, SIGNAL(setRack(const Quackle::Rack &)), this, SLOT(setRack(const Quackle::Rack &)));
}

void TopLevel::plugIntoPositionMatrix(View *view)
{
	connect(this, SIGNAL(positionChanged(const Quackle::GamePosition &)), view, SLOT(positionChanged(const Quackle::GamePosition &)));
}

void TopLevel::plugIntoMoveMatrix(View *view)
{
	connect(this, SIGNAL(movesChanged(const Quackle::MoveList &)), view, SLOT(movesChanged(const Quackle::MoveList &)));
}

void TopLevel::plugIntoHistoryMatrix(HistoryView *view)
{
	plugIntoBaseMatrix(view);

	connect(view, SIGNAL(goToHistoryLocation(const Quackle::HistoryLocation &)), this, SLOT(goToHistoryLocation(const Quackle::HistoryLocation &)));

	connect(this, SIGNAL(historyChanged(const Quackle::History &)), view, SLOT(historyChanged(const Quackle::History &)));
}

int TopLevel::askToSave()
{
	return QMessageBox::warning(this, tr("Unsaved Results - Quackle"), tr("There are unsaved results in the current game. Save them?"), tr("&Save"), tr("&Discard"), tr("&Cancel"), 0, 2);
}

void TopLevel::generateList()
{
	return unimplemented();
	if (!setupCheck())
		return;
	
	pause(true);

	/*
	QString filename(ListerDialog::run(this, m_dict));
	if (!filename.isEmpty())
	{
		if (m_modified)
		{
			switch (askToSave())
			{
				case 0:
					writeFile();

				case 1:
					break;

				case 2:
					return;
			}
		}

		m_filename = filename;
		loadFile();
	}
	*/
}

void TopLevel::kibitz()
{
	const int extraPlaysToKibitz = 10;
	const int currentlyKibitzed = m_game->currentPosition().moves().size();
	kibitz(currentlyKibitzed < extraPlaysToKibitz? extraPlaysToKibitz : currentlyKibitzed + extraPlaysToKibitz);
}

void TopLevel::kibitz(int numberOfPlays)
{
	m_game->currentPosition().kibitz(numberOfPlays);

	updatePositionViews();
	ensureUpToDateSimulatorMoveList();

	switchToTab(ChoicesTabIndex);
}

void TopLevel::kibitzAll()
{
	m_game->currentPosition().kibitz(INT_MAX);

	updatePositionViews();
	ensureUpToDateSimulatorMoveList();

	switchToTab(ChoicesTabIndex);
}

void TopLevel::ensureUpToDateSimulatorMoveList()
{
	m_simulator->setIncludedMoves(m_game->currentPosition().moves());
}

void TopLevel::simulate(bool startSimulation)
{
	m_simulateAction->setChecked(startSimulation);

	// it's not so useful to have sim control show/hide
	// like this
	//m_simulatorWidget->setVisible(startSimulation);

	if (startSimulation)
	{
		logfileChanged();
		incrementSimulation();
	}
	else
		m_simulationTimer->stop();
}

void TopLevel::timeout()
{
	wcout << "toplevel::timeout" << endl;
}

void TopLevel::pliesSet(const QString &plyString)
{
	if (plyString == tr("Many"))
		m_plies = -1;
	else
		m_plies = plyString.toInt();
}

void TopLevel::ignoreOpposChanged()
{
	m_simulator->setIgnoreOppos(m_ignoreOpposCheck->isChecked());
}

void TopLevel::updatePliesCombo()
{
	int index;

	if (m_plies == -1)
		index = m_pliesToOffer;
	else
		index = m_plies - 1;

	m_pliesCombo->setCurrentIndex(index);
}

void TopLevel::logfileEnabled(bool on)
{
	setLogfileEnabled(on);
}

void TopLevel::setLogfileEnabled(bool /* enabled */)
{
	// not needed with QGroupBox
	//m_logfileChooser->setEnabled(enabled);
	//m_logfileEdit->setEnabled(enabled);

	logfileChanged();
}

bool TopLevel::isLogfileEnabled() const
{
	return m_logfileEnable->isChecked();
}

QString TopLevel::userSpecifiedLogfile() const
{
	return m_logfileEdit->text();
}

QString TopLevel::logfile() const
{
	return isLogfileEnabled()? userSpecifiedLogfile() : QString("");
}

void TopLevel::logfileChanged()
{
	m_simulator->setLogfile(Util::qstringToStdString(logfile()), /* append */ true);
}

void TopLevel::chooseLogfile()
{
	QString filename;

	QFileDialog *fileDialog = new QFileDialog(this, tr("Choose log file"));

	fileDialog->setDirectory(userSpecifiedLogfile().isEmpty()? QDir::currentPath() : QFileInfo(userSpecifiedLogfile()).absolutePath());
	fileDialog->setFileMode(QFileDialog::AnyFile);
	fileDialog->setConfirmOverwrite(false);

	if (fileDialog->exec())
	{
		QStringList files(fileDialog->selectedFiles());
		if (!files.empty())
			filename = files.back();
	}

	if (filename.isEmpty())
		return;

	m_logfileEdit->setText(filename);
	logfileChanged();
}

void TopLevel::showSimulationDetails()
{
	if (!m_simViewer)
		m_simViewer = new SimViewer(this);

	m_simViewer->setSimulator(*m_simulator);
	m_simViewer->show();
}

void TopLevel::incrementSimulation()
{
	if (m_simulateAction->isChecked())
	{
		m_simulator->simulate(m_plies);
		m_simulationTimer->start(0);

		updateMoveViews();
		updateSimViews();
	}
}

void TopLevel::updateSimViews()
{
	m_simulatorWidget->setTitle(m_simulator->hasSimulationResults()? tr("Simulation: %2 iterations").arg(m_simulator->iterations()) : tr("Simulation"));

	if (m_simViewer)
		m_simViewer->setSimulator(*m_simulator);
}

void TopLevel::loadFile()
{
	if (m_filename.isEmpty())
		return;

	QString filename(m_filename.right(m_filename.length() - m_filename.lastIndexOf("/") - 1));
	statusMessage(tr("Loading %1...").arg(filename));
	qApp->processEvents();

	QFile file(m_filename);
	if (!file.exists())
	{
		QMessageBox::critical(this, tr("Error Loading Game File - Quackle"), tr("Filename %1 does not exist").arg(m_filename));
		return;
	}

	if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
		return;

	QTextStream stream(&file);
	QString line;

	bool firstLine = true;

	while (!stream.atEnd())
	{
		line = stream.readLine().simplified().toUpper();

		if (firstLine)
			firstLine = false;
	}

	file.close();

	if (!setupCheck())
		return;

	// ...

	statusMessage(tr("Loaded game `%1'").arg(filename));
	setCaption(filename);

	setModified(false);
	pause(true);
}

void TopLevel::writeFile()
{
	return unimplemented();
	setModified(false);
	statusMessage(tr("Saved game to file."));
	
	/*
	QFile file(m_filename);
	 
	if (!file.open(IO_WriteOnly))    
	{        
		QMessageBox::critical(0, tr("Error Writing File - Quacker"), tr("Could not open %1 for writing.").arg(m_filename));        
		return;    
	}    

	QTextStream stream(&file);

	//...

	file.close();
	*/
}

void TopLevel::pause(bool paused)
{
	timerControl(paused);

	if (m_pauseAction->isChecked() != paused)
		m_pauseAction->setChecked(paused);

	if (!paused)
	{
		// set focus to widget that should have focus
		m_brb->grabFocus();
	}

	if (paused)
		statusMessage(tr("Paused."));
	else
		statusMessage(tr("Resuming..."));
}

void TopLevel::advanceGame()
{
	if (m_game->currentPosition().currentPlayer().type() == Quackle::Player::ComputerPlayer)
		m_game->haveComputerPlay();

	itIsNowHumanTurn();

	if (!m_game->currentPosition().gameOver() && m_game->currentPosition().currentPlayer().type() == Quackle::Player::ComputerPlayer)
	{
		QTimer::singleShot(0, this, SLOT(advanceGame()));
		return;
	}
}

void TopLevel::itIsNowHumanTurn()
{
	m_simulator->setPosition(m_game->currentPosition());

	updateHistoryViews();
	updatePositionViews();

	ensureUpToDateSimulatorMoveList();
	updateSimViews();

	if (m_game->currentPosition().gameOver())
	{
		pause(true);

		statusMessage(tr("Game over."));
	}
	else
	{
		pause(false);

		if (m_game->currentPosition().currentPlayer().drawnLetters().empty())
			statusMessage(tr("%1 to play").arg(Util::stringToQString(m_game->currentPosition().currentPlayer().name())));
		else
			statusMessage(tr("%1 to play after drawing %2").arg(Util::stringToQString(m_game->currentPosition().currentPlayer().name())).arg(Util::stringToQString(m_game->currentPosition().currentPlayer().drawnLetters().tiles())));
	}

	switchToTab(HistoryTabIndex);

	// DEBUG RACKS AND BAG
	//wcout << m_game->currentPosition();
}

void TopLevel::timerControl(bool paused)
{
	if (paused)
		m_timer->stop();
	else
	{
		// start timer
		// eg m_timer->start(timerLength(), /* single shot */ true);
		// except we'll want a non-single-shot job
	}
}

QString TopLevel::gameTitle()
{
	QString ret;
	Quackle::PlayerList players(m_game->players());

	if (players.size() == 0)
		ret = tr("No Game");
	else if (players.size() == 1)
		ret = tr("%1's solo game").arg(Util::stringToQString(players.front().name()));
	else if (players.size() == 2)
		ret = tr("%1 versus %2").arg(Util::stringToQString(players.front().name())).arg(Util::stringToQString(players.at(1).name()));
	else if (players.size() > 2)
		ret = tr("Game between %1 and friends").arg(Util::stringToQString(players.front().name()));

	return ret;
}

QString TopLevel::arrangeLettersForUser(const QString &word) 
{
	QString sortOrder = "ABCDEFGHIJKLMNOPQRSTUVWXYZ?";
	
	if (m_quackerSettings.vowelFirst)
		sortOrder = "AEIOUBCDFGHJKLMNPQRSTVWXYZ?";

	return Util::arrangeLetters(word, sortOrder);
}

QString TopLevel::arrangeLettersForUser(const Quackle::Rack &rack)
{
	return arrangeLettersForUser(rack.tiles());
}

void TopLevel::createMenu()
{
	//// Game menu
	
	QAction *newAction = new QAction(tr("&New game..."), this);
	newAction->setShortcut(tr("Ctrl+N"));
	connect(newAction, SIGNAL(triggered()), this, SLOT(newGame()));

	QAction *openAction = new QAction(tr("&Open..."), this);
	openAction->setShortcut(tr("Ctrl+O"));
	connect(openAction, SIGNAL(triggered()), this, SLOT(open()));

	QAction *saveAction = new QAction(tr("&Save"), this);
	saveAction->setShortcut(tr("Ctrl+S"));
	connect(saveAction, SIGNAL(triggered()), this, SLOT(writeFile()));

	QAction *generateAction = new QAction(tr("Generate &list..."), this);
	generateAction->setShortcut(tr("Ctrl+L"));
	connect(generateAction, SIGNAL(triggered()), this, SLOT(generateList()));

	QAction *printAction = new QAction(tr("&Print"), this);
	connect(printAction, SIGNAL(triggered()), this, SLOT(print()));

	m_pauseAction = new QAction(tr("Pa&use"), this);
	m_pauseAction->setShortcut(tr("Ctrl+P"));
	m_pauseAction->setCheckable(true);
	connect(m_pauseAction, SIGNAL(toggled(bool)), this, SLOT(pause(bool)));

	QAction *quitAction = new QAction(tr("&Quit"), this);
	quitAction->setShortcut(tr("Ctrl+Q"));
	connect(quitAction, SIGNAL(triggered()), this, SLOT(close()));

	//// Move

	m_commitAction = new QAction(tr("Co&mmit"), this);
	m_commitAction->setShortcut(tr("Ctrl+M"));
	m_commitAction->setEnabled(false);
	connect(m_commitAction, SIGNAL(triggered()), this, SLOT(commit()));

	m_kibitzAction = new QAction(tr("&Generate choices"), this);
	m_kibitzAction->setShortcut(tr("Ctrl+G"));
	m_kibitzAction->setEnabled(false);
	connect(m_kibitzAction, SIGNAL(triggered()), this, SLOT(kibitz()));

	m_kibitzAllAction = new QAction(tr("&Generate all choices"), this);
	m_kibitzAllAction->setEnabled(false);
	connect(m_kibitzAllAction, SIGNAL(triggered()), this, SLOT(kibitzAll()));

	m_simulateAction = new QAction(tr("Simul&ate"), this);
	m_simulateAction->setShortcut(tr("Ctrl+A"));
	m_simulateAction->setCheckable(true);
	m_simulateAction->setEnabled(false);
	connect(m_simulateAction, SIGNAL(toggled(bool)), this, SLOT(simulate(bool)));

	//// Help

	QAction *aboutAction = new QAction(tr("&About Quackle"), this);
	connect(aboutAction, SIGNAL(triggered()), this, SLOT(about()));

	QAction *aboutQtAction = new QAction(tr("About &Qt"), this);
	connect(aboutQtAction, SIGNAL(triggered()), qApp, SLOT(aboutQt()));

	////

	QMenu *game = menuBar()->addMenu(tr("&Game"));

	game->addAction(newAction);
	game->addAction(openAction);
	game->addAction(saveAction);
	game->addSeparator();
	game->addAction(generateAction);
	game->addAction(m_pauseAction);
	game->addSeparator();
	game->addAction(printAction);
	game->addSeparator();
	game->addAction(quitAction);

	QMenu *move = menuBar()->addMenu(tr("&Move"));
	move->addAction(m_commitAction);
	move->addSeparator();
	move->addAction(m_kibitzAction);
	move->addAction(m_kibitzAllAction);
	move->addAction(m_simulateAction);

	//QMenu *settings = menuBar()->addMenu(tr("&Settings"));

	menuBar()->addSeparator();

	QMenu *help = menuBar()->addMenu(tr("&Help"));
	help->addAction(aboutAction);
	help->addAction(aboutQtAction);

	// move toolbar
	QToolBar *fileBar = addToolBar(tr("File"));
	fileBar->addAction(newAction);
	QToolBar *moveBar = addToolBar(tr("Move"));
	moveBar->addAction(m_commitAction);
	moveBar->addSeparator();
	moveBar->addAction(m_kibitzAction);
	moveBar->addAction(m_simulateAction);
}

void TopLevel::createWidgets()
{
	m_splitter = new QSplitter(Qt::Horizontal, this);

	setCentralWidget(m_splitter);

	QWidget *leftSide = new QWidget;
	QVBoxLayout *leftSideLayout = new QVBoxLayout(leftSide);

	m_dashboard = new Dashboard;
	plugIntoHistoryMatrix(m_dashboard);

	m_choicesWidget = new QWidget;
	QVBoxLayout *choicesLayout = new QVBoxLayout(m_choicesWidget);

	m_simulatorWidget = new QGroupBox(tr("Simulation"));
	QVBoxLayout *simulatorLayout = new QVBoxLayout(m_simulatorWidget);

	QHBoxLayout *plyLayout = new QHBoxLayout;

	m_pliesCombo = new QComboBox;
	QStringList plyOptions;

	for (int i = 1; i <= m_pliesToOffer; ++i)
		plyOptions.push_back(QString::number(i));

	plyOptions.push_back(tr("Many"));

	m_pliesCombo->addItems(plyOptions);
	connect(m_pliesCombo, SIGNAL(activated(const QString &)), this, SLOT(pliesSet(const QString &)));

	QLabel *plyLabel = new QLabel(tr("p&lies"));
	plyLabel->setBuddy(m_pliesCombo);

	m_ignoreOpposCheck = new QCheckBox(tr("oppos pass"));
	connect(m_ignoreOpposCheck, SIGNAL(stateChanged(int)), this, SLOT(ignoreOpposChanged()));

	m_showDetailsButton = new QPushButton(tr("&Details"));
	connect(m_showDetailsButton, SIGNAL(clicked()), this, SLOT(showSimulationDetails()));
	m_simViewer = 0;

	plyLayout->addWidget(m_pliesCombo);
	plyLayout->addWidget(plyLabel);
	plyLayout->addWidget(m_ignoreOpposCheck);
	plyLayout->addStretch();
	plyLayout->addWidget(m_showDetailsButton);
	simulatorLayout->addLayout(plyLayout);

	m_logfileEnable = new QGroupBox(tr("&Log to file"));
	m_logfileEnable->setCheckable(true);
	m_logfileEnable->setFlat(true);
	connect(m_logfileEnable, SIGNAL(toggled(bool)), this, SLOT(logfileEnabled(bool)));

	QHBoxLayout *logfileLayout = new QHBoxLayout(m_logfileEnable);
	logfileLayout->setMargin(0);

	m_logfileEdit = new QLineEdit;
	connect(m_logfileEdit, SIGNAL(returnPressed()), this, SLOT(logfileChanged()));

	m_logfileChooser = new QPushButton(tr("Browse..."));
	connect(m_logfileChooser, SIGNAL(clicked()), this, SLOT(chooseLogfile()));

	logfileLayout->addWidget(m_logfileEdit);
	logfileLayout->addWidget(m_logfileChooser);
	simulatorLayout->addWidget(m_logfileEnable);

	m_moveBox = new MoveBox;
	plugIntoMatrix(m_moveBox);
	plugIntoPositionMatrix(m_moveBox);
	plugIntoMoveMatrix(m_moveBox);

	choicesLayout->addWidget(m_moveBox);
	choicesLayout->addWidget(m_simulatorWidget);

	m_history = new History;
	plugIntoHistoryMatrix(m_history);

	m_tabWidget = new QTabWidget;
	m_tabWidget->addTab(m_history, tr("&History"));
	m_tabWidget->addTab(m_choicesWidget, tr("&Choices"));

	GraphicalFactory factory;
	m_brb = new BRB(&factory);
	plugIntoMatrix(m_brb);
	plugIntoPositionMatrix(m_brb);

	leftSideLayout->addWidget(m_dashboard);
	leftSideLayout->addWidget(m_tabWidget);

	m_splitter->addWidget(leftSide);
	m_splitter->addWidget(m_brb);

	m_splitter->setStretchFactor(1, 4);
}

void TopLevel::switchToTab(TabIndex index)
{
	m_tabWidget->setCurrentIndex(index);
}

void TopLevel::unimplemented()
{
	QMessageBox::information(this, tr("Sorry - Quackle"), tr("This feature is not implemented. Please bug us about it."));
}

void TopLevel::print()
{
	return unimplemented();
	pause(true);

	QString filename = QFileDialog::getSaveFileName(this, tr("Choose file to print to"), m_filename + ".html");

	if (filename.isEmpty())
		return;

	QFile file(filename);
	 
	if (!file.open(QIODevice::ReadOnly | QIODevice::Text))    
	{        
		QMessageBox::critical(0, tr("Error Writing File - Quackle"), tr("Could not open %1 for writing.").arg(file.fileName()));        
		return;    
	}

	QTextStream stream(&file);
	//stream << printer.html() << "\n";

	file.close();

	statusMessage(tr("%1 written.").arg(filename));
}

void TopLevel::about()
{
	QMessageBox::about(this, tr("About Quackle"), "<p><b>Quackle</b> is a crossword game playing, analysis, and study tool. Visit the Quackle homepage at <tt>http://quackle.org</tt> for more information.<p>Copyright 2005-2006 by<ul><li>Jason Katz-Brown &lt;jasonkb@mit.edu&gt;</li><li>John O'Laughlin &lt;olaughlin@gmail.com&gt;</li></ul>");
}

void TopLevel::saveSettings()
{
    //m_quackerSettings.dictGaddagFilename = m_dict->gaddagfilename();

	m_quackerSettings.writeSettings();

	QSettings settings;

	settings.setValue("quackle/window-size", size());
	settings.setValue("quackle/splitter-sizes", m_splitter->saveState());
	settings.setValue("quackle/plies", m_plies);
	settings.setValue("quackle/ignoreoppos", m_ignoreOpposCheck->isChecked());
	settings.setValue("quackle/logfileEnabled", isLogfileEnabled());
	settings.setValue("quackle/logfile", userSpecifiedLogfile());
}

void TopLevel::loadSettings()
{
	m_quackerSettings.readSettings();

    //m_dict->setGaddagFilename(m_quackerSettings.dictGaddagFilename);

	QSettings settings;

	resize(settings.value("quackle/window-size", QSize(600, 400)).toSize());

	if (settings.contains("quackle/splitter-sizes"))
		m_splitter->restoreState(settings.value("quackle/splitter-sizes").toByteArray());

	m_plies = settings.value("quackle/plies", 2).toInt();
	updatePliesCombo();

	m_ignoreOpposCheck->setChecked(settings.value("quackle/ignoreoppos", false).toBool());

	m_logfileEdit->setText(settings.value("quackle/logfile", QString("")).toString());
	const bool logfileEnabled = settings.value("quackle/logfileEnabled", false).toBool();
	m_logfileEnable->setChecked(logfileEnabled);
	setLogfileEnabled(logfileEnabled);
}

////////////////////

QuackerSettings::QuackerSettings()
	: vowelFirst(false), mode(Mode_TWL)
{
}

void QuackerSettings::readSettings()
{
	QSettings settings;

    dictGaddagFilename = settings.value("quackle/gaddagfilename", dictGaddagFilename).toString();

	vowelFirst = settings.value("quackle/vowelFirst", vowelFirst).toBool();

	mode = (QuackerMode)settings.value("quackle/mode", (int)mode).toInt();
}

void QuackerSettings::writeSettings()
{
	QSettings settings;

	settings.setValue("quackle/gaddagfilename", dictGaddagFilename);

	settings.setValue("quackle/vowelFirst", vowelFirst);

	settings.setValue("quackle/mode", mode);
}

