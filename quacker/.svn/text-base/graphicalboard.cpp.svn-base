/*
 * Copyright (c) 2005-2006 Jason Katz-Brown and John O'Laughlin.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The names of the authors may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <iostream>
#include <math.h>

#include <QtGui>

#include <game.h>
#include <move.h>

#include "graphicalboard.h"
#include "util.h"

const double GraphicalBoardFrame::s_markOtherLengthMultiplier;
const int GraphicalBoardFrame::s_highlightFactor;

GraphicalBoard::GraphicalBoard(QWidget *parent)
	: BoardWithQuickEntry(parent)
{
	m_boardFrame = new GraphicalBoardFrame;
	connect(m_boardFrame, SIGNAL(localCandidateChanged(const Quackle::Move &)), this, SLOT(setLocalCandidate(const Quackle::Move &)));

	m_boardWrapper = new QWidget;

	QVBoxLayout *helperLayout = new QVBoxLayout(m_boardWrapper);
	helperLayout->setMargin(0);

	m_vlayout->addWidget(m_boardWrapper);
	helperLayout->addWidget(m_boardFrame);
	m_vlayout->setStretchFactor(m_boardWrapper, 10);

	m_subviews.push_back(m_boardFrame);
	connectSubviewSignals();
}

GraphicalBoard::~GraphicalBoard()
{
}

void GraphicalBoard::expandToFullWidth()
{
	m_boardFrame->expandToSize(m_boardWrapper->size());
}

void GraphicalBoard::resizeEvent(QResizeEvent * /* event */)
{
	QTimer::singleShot(0, this, SLOT(expandToFullWidth()));
}

///////////////////

GraphicalBoardFrame::GraphicalBoardFrame(QWidget *parent)
	: View(parent), m_boardSize(0, 0), m_sideLength(0)
{
	setFrameStyle(QFrame::StyledPanel | QFrame::Raised);
	setLineWidth(2);

	setSizePolicy(QSizePolicy::Maximum, QSizePolicy::Maximum);
	setFocusPolicy(Qt::StrongFocus);

	QColor color(PixmapCacher::self()->markColor);
	QPalette customPalette;
	customPalette.setColor(QPalette::Light, color.light(s_highlightFactor));
	customPalette.setColor(QPalette::Mid, color);
	customPalette.setColor(QPalette::Dark, color.dark(130));
	setPalette(customPalette);

	m_pixmapCacher.tileFont = font();

	//expandToSize(QSize(15 * 25, 15 * 25));

	m_board.prepareEmptyBoard();
	m_candidate = Quackle::Move::createNonmove();
	resetArrow();
}

GraphicalBoardFrame::~GraphicalBoardFrame()
{
}

void GraphicalBoardFrame::positionChanged(const Quackle::GamePosition &position)
{
	m_board = position.board();

	resetArrow();
	m_candidate = position.moveMade();

	prepare();
}

void GraphicalBoardFrame::prepare()
{
	drawBoard(m_board);
	drawMove(m_candidate);
	drawArrow(m_arrowRoot, m_arrowDirection);

	m_pixmap = generateBoardPixmap();
	update();
}

void GraphicalBoardFrame::expandToSize(const QSize &maxSize)
{
	m_maxSize = maxSize;

	// if empty we delay this call
	if (m_boardSize.isEmpty())
		return;
	else
	{
		// TODO we get here too often while resizing

		// do calculations in terms of one axis, arbitrarily, width
		QSize lastCandidate;
		QSize candidate(0, 0);
		do
		{
			lastCandidate = candidate;
			candidate += m_boardSize;
		}
		while (candidate.width() < m_maxSize.width() && candidate.height() < m_maxSize.height());

		const int maxWidth = lastCandidate.width();

		const double numBlocksWidthwise = ((double)m_boardSize.width() + s_markOtherLengthMultiplier);

		m_sideLength = (int)floor((maxWidth - frameWidth() * 2) / numBlocksWidthwise);
		resizeWidgets(m_sideLength);

		const int shorterMarkWidth = markAt(QSize(0, 0))->size().width();
		const int shorterMarkHeight = markAt(QSize(0, 0))->size().height();
		m_tilesOffset.setX(shorterMarkWidth);
		m_tilesOffset.setY(shorterMarkHeight);

		m_sizeForBoard.setWidth(shorterMarkWidth + m_boardSize.width() * m_sideLength);
		m_sizeForBoard.setHeight(shorterMarkHeight + m_boardSize.height() * m_sideLength);
		setMaximumSize(m_sizeForBoard + QSize(frameWidth() * 2, frameWidth() * 2));

		prepare();
	}
}

QPixmap GraphicalBoardFrame::generateBoardPixmap()
{
	QPixmap ret(m_sizeForBoard);
	QPainter painter(&ret);

    for (QSize currentTile(0, 0); currentTile.height() < m_boardSize.height(); currentTile.setHeight(currentTile.height() + 1))
	{
    	for (currentTile.setWidth(0); currentTile.width() < m_boardSize.width(); currentTile.setWidth(currentTile.width() + 1))
		{
			TileWidget *tile = tileAt(currentTile);
			if (!tile)
				continue;

			painter.drawPixmap(coordinatesOfTile(currentTile), tile->tilePixmap());
		}
	}

	for (int row = 0; row <= m_boardSize.height(); ++row)
	{
		const QSize location(0, row);
		painter.drawPixmap(coordinatesOfMark(location), markAt(location)->tilePixmap());
	}

	for (int col = 1; col <= m_boardSize.width(); ++col)
	{
		const QSize location(col, 0);
		painter.drawPixmap(coordinatesOfMark(location), markAt(location)->tilePixmap());
	}

	return ret;
}

void GraphicalBoardFrame::drawBoard(const Quackle::Board &board)
{
	QSize newBoardSize(board.width(), board.height());

	if (m_boardSize != newBoardSize)
	{
		// if it was empty, we need to recalculate
		// tile widths
		bool wasEmpty = m_boardSize.isEmpty();
		
		deleteWidgets();
		m_boardSize = newBoardSize;
		recreateWidgets();

		if (wasEmpty)
			expandToSize(m_maxSize);
	}

    for (QSize currentTile(0, 0); currentTile.height() < m_boardSize.height(); currentTile.setHeight(currentTile.height() + 1))
	{
    	for (currentTile.setWidth(0); currentTile.width() < m_boardSize.width(); currentTile.setWidth(currentTile.width() + 1))
		{
			Quackle::Board::TileInformation info(board.tileInformation(currentTile.height(), currentTile.width()));

			TileWidget *tile = tileAt(currentTile);
			if (!tile)
				continue;

			tile->setInformation(info);

			tile->setArrowDirection(NoArrow);
			tile->setCemented(info.tileType == Quackle::Board::LetterTile);
			tile->prepare();
		}
	}
}

TileWidget *GraphicalBoardFrame::tileAt(const QSize &loc)
{
	QSize mapEntry(loc + QSize(1, 1));
	if (!m_tileWidgets.contains(mapEntry))
	{
		cerr << "error! graphical board can't find a tile" << endl;
		return 0;
	}

	return m_tileWidgets.value(mapEntry);
}

QSize GraphicalBoardFrame::locationForPosition(const QPoint &pos)
{
	QPoint semiRegularized = (pos - QPoint(frameWidth(), frameWidth()) - m_tilesOffset);
	QSize finalSize((int)floor((double)semiRegularized.x() / m_sideLength), (int)floor((double)semiRegularized.y() / m_sideLength));
	return finalSize;
}

TileWidget *GraphicalBoardFrame::markAt(const QSize &loc)
{
	if (!m_tileWidgets.contains(loc))
	{
		cerr << "error! graphical board can't find a mark" << endl;
		return 0;
	}

	return m_tileWidgets.value(loc);
}

void GraphicalBoardFrame::addTile(const QSize &loc, TileWidget *tile)
{
	m_tileWidgets.insert(loc + QSize(1, 1), tile);
}

void GraphicalBoardFrame::removeTile(const QSize &loc)
{
	m_tileWidgets.remove(loc + QSize(1, 1));
}

void GraphicalBoardFrame::addMark(const QSize &loc, MarkWidget *tile)
{
	m_tileWidgets.insert(loc, tile);
}

void GraphicalBoardFrame::removeMark(const QSize &loc)
{
	m_tileWidgets.remove(loc);
}

QPoint GraphicalBoardFrame::coordinatesOfTile(const QSize &loc)
{
	QPoint point(loc.width(), loc.height());
	return (point * m_sideLength) + m_tilesOffset;
}

QPoint GraphicalBoardFrame::coordinatesOfMark(const QSize &loc)
{
	QPoint point(loc.width(), loc.height());

	if (loc == QSize(0, 0))
		return point;
	
	QPoint vector(point.x() == 0? 0 : 1, point.y() == 0? 0 : 1);

	return ((point - vector) * m_sideLength + QPoint(m_tilesOffset.x() * vector.x(), m_tilesOffset.y() * vector.y()));
}

void GraphicalBoardFrame::drawMove(const Quackle::Move &move)
{
	if (move.action == Quackle::Move::Place)
	{
		if (move.tiles().empty())
			return;

		const QSize startTile(move.startcol, move.startrow);

		const Quackle::LetterString::const_iterator end(move.tiles().end());
		int i = 0;
		for (Quackle::LetterString::const_iterator it = move.tiles().begin(); it != end; ++it, ++i)
		{
			// if this is a cemented letter that we shouldn't overwrite
			if (move.isAlreadyOnBoard(*it))
				continue;

			QSize currentTile(startTile);
			if (move.horizontal)
				currentTile.setWidth(currentTile.width() + i);
			else
				currentTile.setHeight(currentTile.height() + i);

			TileWidget *tileWidget = tileAt(currentTile);
			if (!tileWidget)
				continue;

			Quackle::Board::TileInformation info;
			info.tileType = Quackle::Board::LetterTile;

			info.isBlank = QUACKLE_ALPHABET_PARAMETERS->isBlankLetter(*it);
			info.letter = QUACKLE_ALPHABET_PARAMETERS->userVisible(QUACKLE_ALPHABET_PARAMETERS->clearBlankness(*it));

			tileWidget->setInformation(info);
			tileWidget->setCemented(false);
			tileWidget->prepare();
		}
	}
}

void GraphicalBoardFrame::drawArrow(const QSize &location, int arrowDirection)
{
	TileWidget *tile = tileAt(location);
	if (!tile)
		return;

	tile->setArrowDirection(arrowDirection);
	tile->prepare();
}

void GraphicalBoardFrame::deleteWidgets()
{
	if (m_boardSize.isEmpty())
		return;

    for (QSize currentTile(0, 0); currentTile.height() < m_boardSize.height(); currentTile.setHeight(currentTile.height() + 1))
	{
    	for (currentTile.setWidth(0); currentTile.width() < m_boardSize.width(); currentTile.setWidth(currentTile.width() + 1))
		{
			delete tileAt(currentTile);
			removeTile(currentTile);
		}
	}

	for (int row = 0; row <= m_boardSize.height(); ++row)
	{
		delete markAt(QSize(0, row));
		removeMark(QSize(0, row));
	}

	for (int col = 1; col <= m_boardSize.width(); ++col)
	{
		delete markAt(QSize(col, 0));
		removeMark(QSize(col, 0));
	}
}

void GraphicalBoardFrame::recreateWidgets()
{
	Quackle::Board emptyBoard;
	emptyBoard.prepareEmptyBoard();

    for (QSize currentTile(0, 0); currentTile.height() < m_boardSize.height(); currentTile.setHeight(currentTile.height() + 1))
	{
    	for (currentTile.setWidth(0); currentTile.width() < m_boardSize.width(); currentTile.setWidth(currentTile.width() + 1))
		{
			TileWidget *newTile = new TileWidget;

			newTile->setLocation(currentTile);
			newTile->setOriginalInformation(emptyBoard.tileInformation(currentTile.height(), currentTile.width()));

			addTile(currentTile, newTile);
		}
	}

	for (int row = 0; row <= m_boardSize.height(); ++row)
	{
		MarkWidget *newMark = new MarkWidget;

		if (row == 0)
			newMark->setCapstone();
		else
			newMark->setRow(row);

		addMark(QSize(0, row), newMark);
	}

	for (int col = 1; col <= m_boardSize.width(); ++col)
	{
		MarkWidget *newMark = new MarkWidget;
		newMark->setCol(col);
		addMark(QSize(col, 0), newMark);
	}
}

void GraphicalBoardFrame::resizeWidgets(int sideLength)
{
	m_pixmapCacher.invalidate();

	bool firstTile = true;
    for (QSize currentTile(0, 0); currentTile.height() < m_boardSize.height(); currentTile.setHeight(currentTile.height() + 1))
	{
    	for (currentTile.setWidth(0); currentTile.width() < m_boardSize.width(); currentTile.setWidth(currentTile.width() + 1))
		{
			TileWidget *tile = tileAt(currentTile);
			if (!tile)
				continue;

			tile->setSideLength(sideLength);

			if (firstTile)
			{
				emit tileFontChanged(tile->letterFont());
				firstTile = false;
			}
		}
	}

	for (int row = 0; row <= m_boardSize.height(); ++row)
	{
		TileWidget *mark = markAt(QSize(0, row));
		mark->setSideLength(sideLength);
	}

	for (int col = 1; col <= m_boardSize.width(); ++col)
	{
		TileWidget *mark = markAt(QSize(col, 0));
		mark->setSideLength(sideLength);
	}
}

void GraphicalBoardFrame::paintEvent(QPaintEvent *event)
{
	QPainter painter(this);
	QRect rect(contentsRect());
	painter.drawPixmap(contentsRect().topLeft(), m_pixmap);
	painter.end();

	QFrame::paintEvent(event);
}

void GraphicalBoardFrame::mousePressEvent(QMouseEvent *event)
{
	if (event->button() != Qt::LeftButton)
	{
		event->ignore();
		return;
	}

	const QPoint pos(event->pos());

	QSize location = locationForPosition(pos);

	if (location.isValid())
		tileClicked(location);

	event->accept();
}

void GraphicalBoardFrame::keyPressEvent(QKeyEvent *event)
{
	enum { Backspace = 0, Delete, Submit, Append } mode;

	switch (event->key())
	{
	case Qt::Key_Backspace:
		mode = Backspace;
		break;

	case Qt::Key_Delete:
		mode = Delete;
		break;

	case Qt::Key_Return:
	case Qt::Key_Enter:
		mode = Submit;
		break;

	default:
		mode = Append;
		break;
	}

	if (!hasCandidate())
	{
		event->ignore();
		return;
	}

	switch (mode)
	{

	// these modes need a candidate
	case Submit:
		submitHandler();
		break;
	
	default:
		if (!hasArrow())
		{
			event->ignore();
			return;
		}

		switch (mode)
		{

		// these modes need an arrow
		case Delete:
			deleteHandler();
			break;
		
		case Backspace:
			backspaceHandler();
			break;
		
		case Append:
			if (event->modifiers() & Qt::AltModifier || event->modifiers() & Qt::ControlModifier || event->text().isEmpty())
			{
				event->ignore();
				return;
			}
	
			appendHandler(event->text(), event->modifiers() & Qt::ShiftModifier);
			break;

		case Submit:
			break;
		}
		break;
	}

	prepare();

	event->accept();
}

void GraphicalBoardFrame::prettifyAndSetLocalCandidate(const Quackle::Move &candidate)
{
	m_candidate = candidate;
	m_candidate.setPrettyTiles(m_board.prettyTilesOfMove(m_candidate));
	emit localCandidateChanged(m_candidate);
}

void GraphicalBoardFrame::setLocalCandidate(const Quackle::Move &candidate)
{
	m_candidate = candidate;
	resetArrow();
	prepare();
}

void GraphicalBoardFrame::backspaceHandler()
{
	unsigned int hoppedTiles = 0;
	QSize currentTile(m_arrowRoot);
	while (true)
	{
		const QSize previousTile = currentTile - arrowVector();

		bool stopHere;

		if (!isOnBoard(previousTile))
			stopHere = true;
		else
		{
			Quackle::Board::TileInformation previousTileInformation(m_board.tileInformation(previousTile.height(), previousTile.width()));

			stopHere = previousTileInformation.tileType != Quackle::Board::LetterTile;
		}

		++hoppedTiles;

		if (stopHere)
		{
			m_arrowRoot = previousTile;
			break;
		}

		currentTile = previousTile;
	}

	Quackle::LetterString tiles(m_candidate.tiles());

	if (hoppedTiles >= tiles.length())
		tiles = Quackle::LetterString();
	else
		tiles = Quackle::String::left(m_candidate.tiles(), m_candidate.tiles().length() - hoppedTiles);

	m_candidate.setTiles(tiles);

	ensureCandidatePlacedProperly();
	prettifyAndSetLocalCandidate(m_candidate);
}

void GraphicalBoardFrame::deleteHandler()
{
	setLocalCandidate(Quackle::Move::createNonmove());
}

void GraphicalBoardFrame::submitHandler()
{
	QTimer::singleShot(0, this, SLOT(setGlobalCandidate()));
}

void GraphicalBoardFrame::setGlobalCandidate()
{
	emit setCandidateMove(m_candidate);
}

void GraphicalBoardFrame::appendHandler(const QString &text, bool shiftPressed)
{
	if (!hasCandidate())
		return;

	QString appendedText;
	
	if (shiftPressed)
		appendedText = text.toLower();
	else
		appendedText = text.toUpper();

	Quackle::Move newCandidate(m_candidate);
	newCandidate.setTiles(m_candidate.tiles() + Util::encode(appendedText));

	Quackle::LetterString hoppedTiles;

	QSize currentTile(m_arrowRoot);
	while (true)
	{
		const QSize nextTile = currentTile + arrowVector();

		bool stopHere = false;
		bool resetArrowAfter = false;

		if (!isOnBoard(nextTile))
		{
			stopHere = true;
			resetArrowAfter = true;
		}
		else
		{
			Quackle::Board::TileInformation nextTileInformation(m_board.tileInformation(nextTile.height(), nextTile.width()));

			if (nextTileInformation.tileType != Quackle::Board::LetterTile)
				stopHere = true;
		}

		if (stopHere)
		{
			newCandidate.setTiles(newCandidate.tiles() + hoppedTiles);

			if (resetArrowAfter)
				resetArrow();
			else
				m_arrowRoot = nextTile;

			break;
		}

		hoppedTiles += QUACKLE_PLAYED_THRU_MARK;
		currentTile = nextTile;
	}

	prettifyAndSetLocalCandidate(newCandidate);
}

void GraphicalBoardFrame::tileClicked(const QSize &tileLocation)
{
	Quackle::Board::TileInformation info(m_board.tileInformation(tileLocation.height(), tileLocation.width()));
	if (info.tileType == Quackle::Board::LetterTile)
		return;

	if (m_arrowRoot == tileLocation)
	{
		++m_arrowDirection;
		if (m_arrowDirection == ArrowWorm)
			m_arrowDirection = s_firstArrowDirection;
	}
	else
		m_arrowDirection = s_firstArrowDirection;

	m_arrowRoot = tileLocation;

	Quackle::Move originalMove;
	Quackle::LetterString hoppedTiles;

	QSize currentTile(tileLocation);
	while (true)
	{
		const QSize previousTile = currentTile - arrowVector();

		bool stopHere;

		if (!isOnBoard(previousTile))
			stopHere = true;
		else
		{
			Quackle::Board::TileInformation previousTileInformation(m_board.tileInformation(previousTile.height(), previousTile.width()));

			stopHere = previousTileInformation.tileType != Quackle::Board::LetterTile;
		}

		if (stopHere)
		{
			const bool horizontal = m_arrowDirection == ArrowRight;
			originalMove = Quackle::Move::createPlaceMove(currentTile.height(), currentTile.width(), horizontal, hoppedTiles);
			break;
		}

		hoppedTiles += QUACKLE_PLAYED_THRU_MARK;
		currentTile = previousTile;
	}

	prettifyAndSetLocalCandidate(originalMove);

	// TODO work some cleverness so we can do this!
	//emit setCandidateMove(Quackle::Move::createNonmove());

    for (QSize currentTile(0, 0); currentTile.height() < m_boardSize.height(); currentTile.setHeight(currentTile.height() + 1))
    	for (currentTile.setWidth(0); currentTile.width() < m_boardSize.width(); currentTile.setWidth(currentTile.width() + 1))
			if (currentTile != tileLocation)
			{
				TileWidget *tile = tileAt(currentTile);
				if (!tile)
					continue;

				tile->setArrowDirection(NoArrow);
			}

	prepare();
}

void GraphicalBoardFrame::resetArrow()
{
	m_arrowRoot = QSize(-1, -1);
	m_arrowDirection = NoArrow;
}

bool GraphicalBoardFrame::hasArrow() const
{
	return m_arrowRoot.isValid();
}

QSize GraphicalBoardFrame::arrowVector() const
{
	const bool horizontal = (m_arrowDirection == ArrowRight);
	return horizontal? QSize(1, 0) : QSize(0, 1);
}

bool GraphicalBoardFrame::hasCandidate() const
{
	return m_candidate.isAMove();
}

void GraphicalBoardFrame::ensureCandidatePlacedProperly()
{
	if (m_candidate.tiles().empty())
	{
		m_candidate.startrow = m_arrowRoot.height();
		m_candidate.startcol = m_arrowRoot.width();
	}
}

bool GraphicalBoardFrame::isOnBoard(const QSize &location) const
{
	return (location.width() >= 0 && location.width() < m_boardSize.width() && location.height() >= 0 && location.height() < m_boardSize.height());
}

////////////////

unsigned int qHash(const QColor &color)
{
	return color.rgb();
}

PixmapCacher *PixmapCacher::m_self = 0;
PixmapCacher *PixmapCacher::self()
{
	return m_self;
}

PixmapCacher::PixmapCacher()
{
	m_self = this;

	letterColor = QColor("dimgrey").light(105);
	DLSColor = QColor("cornflowerblue");
	TLSColor = QColor("slateblue");
	DWSColor = QColor("palevioletred");
	TWSColor = QColor("firebrick");
	
	QLSColor = QColor("blue");
	QWSColor = QColor("red");

	nothingColor = QColor("gainsboro");
	cementedLetterTextColor = QColor("ghostwhite");
	uncementedLetterTextColor = QColor("khaki");

	markColor = QColor("tan");
	markTextColor = markColor.dark();
}

bool PixmapCacher::contains(const QColor &color) const
{
	return m_pixmaps.contains(color);
}

QPixmap PixmapCacher::get(const QColor &color) const
{
	return m_pixmaps.value(color);
}

void PixmapCacher::put(const QColor &color, const QPixmap &pixmap)
{
	m_pixmaps.insert(color, pixmap);
}

void PixmapCacher::invalidate()
{
	m_pixmaps.clear();
}

////////////////

TileWidget::TileWidget()
	: m_cemented(false), m_arrowDirection(GraphicalBoardFrame::NoArrow)
{
}

TileWidget::~TileWidget()
{
}

void TileWidget::setSideLength(int sideLength)
{
	setOurSize(sideLength, sideLength);

	if (!m_pixmap.isNull())
		prepare();
}

int TileWidget::sideLength() const
{
	return m_size.width();
}

QSize TileWidget::size() const
{
	return m_size;
}

void TileWidget::setInformation(const Quackle::Board::TileInformation &information)
{
	m_information = information;
}

Quackle::Board::TileInformation TileWidget::information() const
{
	return m_information;
}

void TileWidget::setOriginalInformation(const Quackle::Board::TileInformation &originalInformation)
{
	if (originalInformation.tileType == Quackle::Board::BonusSquareTile)
		m_backgroundColor = tileColor(originalInformation);
}

void TileWidget::setLocation(const QSize &location)
{
	m_location = location;
}

void TileWidget::setCemented(bool cemented)
{
	m_cemented = cemented;
}

bool TileWidget::cemented() const
{
	return m_cemented;
}

void TileWidget::setArrowDirection(int arrowDirection)
{
	m_arrowDirection = arrowDirection;
}

GraphicalBoardFrame::ArrowDirection TileWidget::arrowDirection() const
{
	return (GraphicalBoardFrame::ArrowDirection)m_arrowDirection;
}

void TileWidget::prepare()
{
	m_pixmap = generateTilePixmap();
}

const QPixmap &TileWidget::tilePixmap()
{
	return m_pixmap;
}

QColor TileWidget::tileColor()
{
	return tileColor(m_information);
}

QColor TileWidget::tileColor(const Quackle::Board::TileInformation &information)
{
	QColor ret;

	PixmapCacher *cache = PixmapCacher::self();

	switch (information.tileType)
	{
	case Quackle::Board::LetterTile:
		ret = cache->letterColor;
		break;

	case Quackle::Board::BonusSquareTile:
		switch (information.bonusSquareType)
		{
		case Quackle::Board::LetterBonus:
			if (information.bonusMultiplier == 2)
				ret = cache->DLSColor;
			else if (information.bonusMultiplier == 3)
				ret = cache->TLSColor;
			else if (information.bonusMultiplier == 4)
				ret = cache->QLSColor;
			else
			{
				// TODO general case
			}
			break;

		case Quackle::Board::WordBonus:
			if (information.bonusMultiplier == 2)
				ret = cache->DWSColor;
			else if (information.bonusMultiplier == 3)
				ret = cache->TWSColor;
			else if (information.bonusMultiplier == 4)
				ret = cache->QWSColor;
			else
			{
				// TODO general case
			}
			break;

		case Quackle::Board::NoBonus:
			// urps, this won't happen
			ret = cache->nothingColor;
			break;
		}
		break;

	case Quackle::Board::NothingTile:
		ret = cache->nothingColor;
		break;
	}
	
	return ret;
}

QColor TileWidget::backgroundColor()
{
	return m_backgroundColor;
}

QColor TileWidget::letterTextColor()
{
	QColor ret;

	if (m_arrowDirection != GraphicalBoardFrame::NoArrow)
		ret = PixmapCacher::self()->letterColor;
	else if (m_cemented)
		ret = PixmapCacher::self()->cementedLetterTextColor;
	else
		ret = PixmapCacher::self()->uncementedLetterTextColor;

	return ret;
}

QString TileWidget::letterText()
{
	if (m_arrowDirection == GraphicalBoardFrame::ArrowRight)
		return QString(QChar((unsigned short int)8658));
	else if (m_arrowDirection == GraphicalBoardFrame::ArrowDown)
		return QString(QChar((unsigned short int)8659));
		
	if (m_information.letter.empty() || m_information.letter == QUACKLE_NULL_MARK_TEXT)
		return QString::null;

	return Util::stringToQString(m_information.letter);
}

QFont TileWidget::letterFont()
{
	QFont ret(PixmapCacher::self()->tileFont);
	const float multiplier = m_information.isBlank? .5 : .7;
	ret.setPixelSize((int)(qMin(size().width(), size().height()) * multiplier));
	ret.setBold(true);
	return ret;
}

void TileWidget::setOurSize(const QSize &size)
{
	m_size = size;
}

void TileWidget::setOurSize(int width, int height)
{
	setOurSize(QSize(width, height));
}

QPixmap TileWidget::generateTilePixmap()
{
	const QSize currentSize(size());
	const QRect borderRect(0, 0, currentSize.width(), currentSize.height());
	const int maxSideLength = qMax(currentSize.width(), currentSize.height());
	const int borderWidth = 1;

	const QPointF midpoint((double)(currentSize.width() + borderWidth) / 2, (double)(currentSize.height() + borderWidth) / 2);
	const QColor color(tileColor());

	QPixmap ret(currentSize);

	if (PixmapCacher::self()->contains(color))
		ret = PixmapCacher::self()->get(color);
	else
	{
		//wcout << "cache miss for color " << color.rgb() << endl;
		double radius = maxSideLength / 2 * 1.41 + maxSideLength / 10 + 2;

		// could be used for cool effect -- the color of the bonus square we're obscuring
		//const QColor outerColor(backgroundColor());

		QRadialGradient gradient(QPointF(radius, radius), radius * 3, QPointF(radius / 3, radius / 3));
		gradient.setColorAt(0, color.light(GraphicalBoardFrame::s_highlightFactor));
		gradient.setColorAt(.95, color.dark(GraphicalBoardFrame::s_highlightFactor));

		QPainter painter(&ret);
		painter.setBrush(gradient);
	
		painter.drawEllipse((int)(midpoint.x() - radius), (int)(midpoint.y() - radius), (int)(radius * 2), (int)(radius * 2));

		QPalette customPalette;
		customPalette.setColor(QPalette::Light, color.light(GraphicalBoardFrame::s_highlightFactor));
		customPalette.setColor(QPalette::Dark, color);
		customPalette.setColor(QPalette::Mid, color);

		qDrawShadePanel(&painter, borderRect.x(), borderRect.y(), borderRect.width(), borderRect.height(), customPalette, false, borderWidth);

		PixmapCacher::self()->put(color, ret);
	}

	const QString text(letterText());
	if (!text.isEmpty())
	{
		QPainter painter(&ret);
		painter.setFont(letterFont());
		QPen pen(letterTextColor());
		painter.setPen(pen);
		painter.setBrush(Qt::NoBrush);

		const QRectF textSize(painter.boundingRect(borderRect, text));
		const QPointF startPoint(midpoint - textSize.bottomRight() / 2);
		const QPointF roundedStartPoint(floor(startPoint.x()), floor(startPoint.y()));

		QRectF textRect(textSize);
		textRect.moveTo(roundedStartPoint);

		painter.drawText(textRect, Qt::TextDontClip, text);

		if (m_information.isBlank)
		{
			painter.setBrush(Qt::NoBrush);
			pen.setWidth(1);
			painter.setPen(pen);

			const int border = currentSize.width() * 1/5;
			painter.drawRect(QRect(border, border, currentSize.width() - 2 * border, currentSize.height() - 2 * border));
		}
	}

	return ret;
}

bool operator<(const QSize &firstSize, const QSize &secondSize)
{
	return (firstSize.height() + (QUACKLE_MAXIMUM_BOARD_SIZE + 1) * firstSize.width()) < (secondSize.height() + (QUACKLE_MAXIMUM_BOARD_SIZE + 1) * secondSize.width());
}

//////////////////

MarkWidget::MarkWidget()
	: m_horizontal(true), m_capstone(false)
{
	m_information.tileType = Quackle::Board::LetterTile;
}

MarkWidget::~MarkWidget()
{
}

void MarkWidget::setRow(int row)
{
	m_horizontal = false;
	m_letterText = QString::number(row);
}

void MarkWidget::setCol(int col)
{
	m_horizontal = true;
	m_letterText = QChar('A' + col - 1);
}

void MarkWidget::setCapstone()
{
	m_capstone = true;
	m_letterText = QString::null;
}

void MarkWidget::setSideLength(int sideLength)
{
	const int otherLength = (int)(sideLength * GraphicalBoardFrame::s_markOtherLengthMultiplier);

	if (m_capstone)
		setOurSize(otherLength, otherLength);
	else if (m_horizontal)
		setOurSize(sideLength, otherLength);
	else
		setOurSize(otherLength, sideLength);

	prepare();
}

QColor MarkWidget::tileColor()
{
	// we slightly alter colors to fool the pixmap cacher!
	if (m_capstone)
		return PixmapCacher::self()->markColor.light(101);
	else if (m_horizontal)
		return PixmapCacher::self()->markColor;
	else
		return PixmapCacher::self()->markColor.dark(101);
}

QColor MarkWidget::letterTextColor()
{
	return PixmapCacher::self()->markTextColor;
}

QFont MarkWidget::letterFont()
{
	QFont ret(TileWidget::letterFont());
	ret.setBold(false);
	return ret;
}

QString MarkWidget::letterText()
{
	return m_letterText;
}

